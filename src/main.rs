use ilearn::{run, Config};
use std::{env, error::Error, fs, process};

fn main() {
    /*
     *
     * ## 闭包 Closure
     *
     * 闭包是一种匿名函数，它可以赋值给变量也可以作为参数传递给其它函数，不同于函数的是，它允许捕获调用者作用域中的值。
     *
     * Rust 闭包在形式上借鉴了 Smalltalk 和 Ruby 语言，与函数最大的不同就是它的参数是通过 |parm1| 的形式进行声明，如果是多个参数就 |param1, param2,...|，闭包的形式定义：
     * ```rust
     * |param1, param2,...| {
     *     语句1;
     *     语句2;
     *     返回表达式
     * }
     * ```
     *
     * 如果闭包只有一个返回表达式，可以简化定义：
     *
     * ```rust
     * |param1| 返回表达式
     * ```
     *
     * 特别注意：闭包中最后一行表达式返回的值，就是闭包执行后的返回值。
     *
     * ```rust
     * fn main() {
     *    let x = 1;
     *    let sum = |y| x + y;
     *
     *    assert_eq!(3, sum(2));
     * }
     * ```
     * 代码中闭包 sum，它拥有一个入参 y，同时捕获了作用域中的 x 的值，因此调用 sum(2) 意味着将 2（参数 y）跟 1（x）进行相加，最终返回它们的和：3。
     *
     * 可以看到 sum 非常符合闭包的定义：可以赋值给变量，允许捕获调用者作用域中的值。
     *
     * ### 闭包类型推导
     * Rust 是静态语言，因此所有的变量都具有类型，但是得益于编译器的强大类型推导能力，在很多时候我们并不需要显式地去声明类型，但是显然函数并不在此列，必须手动为函数的所有参数和返回值指定类型，原因在于函数往往会作为 API 提供给你的用户，因此你的用户必须在使用时知道传入参数的类型和返回值类型。
     *
     * 与函数相反，闭包并不会作为 API 对外提供，因此它可以享受编译器的类型推导能力，无需标注参数和返回值的类型。
     *
     * 为了增加代码可读性，有时候我们会显式地给类型进行标注，出于同样的目的，也可以给闭包标注类型，在下面sum函数中，定义两个参数 `x y` 和返回值为 i32 类型。
     * ```rust
     * let sum = |x: i32, y: i32| -> i32 {
     *     x + y
     * }
     * ```
     * 与之相比，不标注类型的闭包声明会更简洁些：let sum = |x, y| x + y，需要注意的是，针对 sum 闭包，如果你只进行了声明，但是没有使用，编译器会提示你为 x, y 添加类型标注，因为它缺乏必要的上下文：
     */
}
