use core::fmt;
use ilearn::{run, Config};
use num::FromPrimitive;
use num_derive::FromPrimitive;
use num_enum::{IntoPrimitive, TryFromPrimitive};
use std::{
    fmt::{Debug, Display},
    ops::{Add, Index},
};

fn main() {
    /*
     * ## 智能指针（二）Box 对象分配
     * `Box<T>` 是 Rust 中最常见的智能指针，功能是将一个值分配到堆上，然后在栈上保留一个**智能指针**指向堆上的数据。
     *
     * 要想用好Box，需要深入了解计算机堆栈概念。
     *
     * **栈**
     *
     * 栈内存从**高位地址向下增长**，且栈内存是连续分配的，一般来说操作系统对栈内存的大小都有限制，因此 C 语言中无法创建任意长度的数组（存储在栈）。
     * 在 Rust 中，main 线程的栈大小是 8MB，普通线程是 2MB，在函数被调用时 Rust 会在线程内存中创建一个**临时栈空间**，调用结束后 Rust 会让这个栈空间里的所有对象自动进入 Drop 流程，最后栈顶指针自动移动到上一个调用栈顶，无需程序员手动干预，因而栈内存申请和释放是非常高效的。
     *
     * **堆**
     *
     * 与栈相反，堆上内存则是从低位地址向上增长，堆内存通常只受物理内存限制，而且通常是不连续的，因此从性能的角度看，栈往往比堆更高。
     *
     * 相比其它语言，Rust 堆上对象还有一个特殊之处，它们都拥有一个所有者，因此**受所有权规则的限制**：当赋值时，发生的是**所有权的转移**（只需浅拷贝栈上的引用或智能指针即可）
     *
     *
     * ```rust
     * fn foo(x: &str) -> String {
     *     let s = "Hello, ".to_string() + x;
     *     s
     * }
     *
     * let
     * println!("{}", foo("World"));
     * ```
     * 在 foo 函数中，s 是一个 String 类型，它是由存储在堆中的实际类型数据和存储在栈中的智能指针结构体（指向堆数据）共同组成的。
     * 当 s 被从 foo 函数转移给 x 变量时，只需要将 s 栈上的智能指针复制一份赋予给 x，而底层数据不发生改变即可完成堆数据的所有权从 foo 函数内部到 x 的转移。
     *
     * ### 栈与堆的性能
     * 很多人可能会觉得栈的性能肯定比堆高，其实未必，这里有一个大概：
     * - 小型数据，在栈上的分配性能和读取性能都要比堆上高
     * - 中型数据，栈上分配性能高，但是读取性能和堆上并无区别，因为无法利用寄存器或 CPU 高速缓存（空间非常小），最终还是要经过一次内存寻址
     * - 大型数据，只建议在堆上分配和使用
     *
     * 总结：栈的**分配速度**比堆快，但是**读取速度**往往取决于数据能不能放入寄存器或 CPU 高速缓存。因此不要因为堆的性能不如栈这个印象，就总是优先选择使用栈，导致代码更复杂的实现。
     *
     * ### Box 的使用场景
     * 由于 Box 是简单的封装，除了将值存储在堆上外，并没有其它性能上的损耗。而性能和功能往往是鱼和熊掌，因此 Box 相比其它智能指针，功能较为单一，可以在以下场景中使用它：
     * - 特意的将数据分配在堆上
     * - 数据较大时，又不想在转移所有权时进行数据拷贝
     * - 类型的大小在编译期无法确定，但是我们又需要固定大小的类型时（递归对象，切片等）
     * - 特征对象，用于说明对象实现了一个特征，而不是某个特定的类型
     *
     * 
     * #### 使用 `Box<T>` 将数据存储在堆上
     * 
     * 如果一个变量拥有一个数值，即直接声明变量 `let a = 3`，那变量 a 必然是存储在栈上的，如果想要 a 的值存储在堆上就需要使用 `Box<T>`：
     * ```rust
     * let a = Box::new(2);
     * println!("a = {}", a); // a = 3
     * // let b = a + 1; // 代码将报错 cannot add `{integer}` to `Box<{integer}>`
     * ```
     * 这样就可以创建一个智能指针指向了存储在堆上的 3，并且 a 持有了该指针。
     * 
     * 
     * 
     *
     *
     */

    let arr1 = [0; 1000];
    let arr2 = arr1; // 由于数组存储在栈上，因此赋值转移时，深拷贝了一份数据
    println!("{:p}, {:p}", &arr1, &arr2);

    fn foo(x: &str) -> String {
        let s = "Hello, ".to_string() + x;
        s
    }
    let x = foo("World");
    println!("{}", x);
}
