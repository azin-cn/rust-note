use core::fmt;
use ilearn::{run, Config};
use std::{
    fmt::{Debug, Display},
    ops::{Add, Index},
};

fn main() {
    /*
     * ## 不定长类型 DST 和定长类型 Sized
     * 
     * 在 Rust 中类型有多种抽象的分类方式，如按照传统数据结构划分：基本类型、集合类型、复合类型等。如果从编译器何时能获知类型大小的角度出发，可以分成两类:
     * - 定长类型( sized )，这些类型的大小在编译时是已知的，实现了 trait Sized。
     * - 不定长类型( unsized )，与定长类型相反，它的大小只有到了**程序运行时**才能动态获知，这种类型又被称之动态大小类型/动态尺寸类型(dynamically sized type)（DST），或者非正式地称为非固定尺寸类型(unsized type)。切片和 trait对象是 DSTs 的两个例子。
     *
     * ### 动态大小类型 DST
     * **动态大小类型/动态尺寸类型(dynamically sized type)（DST），指的类型大小不确定，而不是指数据大小不确定**。
     *
     * 不能简单的将变量与类型视为只是一块栈内存或一块堆内存数据，比如 Vec 类型，rust将其分成两部分数据：存储在堆中的实际类型数据与存储在栈上的管理信息数据。
     * 其中存储在栈上的管理信息数据是引用类型，包含实际类型数据的地址、元素的数量，分配的空间等信息，**rust 通过栈上的管理信息数据掌控实际类型数据的信息**。
     * 这种**存储自身大小信息的类型**就可以称为定长类型（固定尺寸）。
     *
     * 反过来，不存储自身大小信息的就被称为动态尺寸类型（DST），如切片 `[T]` 与 特征对象 `trait object`。
     * 以切片为例，**切片就是数据本身，不包含自身大小信息**，它可以在堆、栈、静态存储区，写作 `[T]`，常见的支持切片的类型有String类型、Array类型和Vec类型。
     * 在 https://www.cnblogs.com/88223100/p/Rust-memory-distribution.html 中有切片的 rust 内存分布，可以清楚的看到切片 `[T]` 就是原始数据本身的一部分，**没有存储自身大小的信息**。
     * 所以在使用切片时，需要通过外部手段（如引用或智能指针）来管理长度信息，如胖指针包含了两份元数据：**指向源数据中切片起点元素的指针和切片数据中包含的元素数量(切片的长度)**。
     * 这种**不存储自身大小信息的类型**就是动态尺寸类型（DST）。
     *
     * **切片 [T]:**
     * - 切片是一个动态尺寸类型（Dynamically Sized Type, DST），它不存储任何有关其长度的信息。
     * - 切片只是对一块连续内存的引用，其长度在使用时必须已知，但不是由切片本身直接存储的。
     * 由于切片的长度不是在编译时已知的，所以不能单独作为一个值来存储；它通常通过某种形式的指针（如 &[T] 或 Box<[T]>）来使用，这些指针包含了长度信息。
     *
     * **向量 `Vec<T>`:**
     * - `Vec<T>` 是一个固定尺寸类型，它在内部维护了一个指向堆上分配的数组的指针、当前向量的长度以及它的容量。这意味着 `Vec<T>` 总是知道自己包含多少元素，并且这些元素占用了多少内存空间。
     * - `Vec<T>` 的这种设计使得它在运行时可以动态地增长或缩小，但其本身的大小（即存储指针、长度和容量的大小）在编译时是已知的。
     *
     * 因此 Vec、String 和 HashMap 等数据类型，虽然底层数据可动态变化，但实际上这些底层数据只是保存在堆上，在栈中还存有一个引用类型，该引用包含了集合的内存地址、元素数目、分配空间信息，也就是类型本身就存储自身的大小信息。
     *
     * 总结来说，尽管 `Vec<T>` 可以动态地改变其存储的数据的大小，但它本身作为一个对象的大小是固定的，包括指向数据的指针、长度和容量。而切片 `[T]` 本身不存储这些信息，需要通过外部手段（如引用或智能指针）来管理这些数据，因此是一个动态尺寸类型。
     * 
     * *存储自身大小信息的类型**称为定长类型，反之称为非定长类型。
     *
     * > 小知识
     * > 
     * > 在rust中，切片不可直接使用，所以一般将切片引用简化称为切片。
     *
     * #### str
     * str 既不是 String 动态字符串，也不是 &str 字符串切片(切片引用)，而是一个字符串切片，是一个动态类型，是 String 和 `&str` 的底层数据类型。
     *
     * 由于 str 是动态类型，因此它的大小直到运行期才知道，所以要使用字符串切片引用（常称为字符串切片）：
     * ```rust
     * // let s1: str = "Hello World!"; 字符串切片，是String和&str的底层数据类型，不可直接使用
     * let s2: &str = "on?"; // 字符串切片引用
     * ```
     *
     * 之前提到过：**切片就是数据本身，不包含自身大小信息**，它可以在堆、栈、静态存储区。
     * str（字符串切片）就是存储在静态存储区的一种**动态尺寸类型**，rust 通过 `&str` （字符串切片引用）管理 str。
     * `&str`（字符串切片引用）存储在栈，属于定长类型，包含有实际数据的内存地址、长度等信息，常用**字符串切片**简化名称，易与真实的字符串切片混淆。
     *
     * #### 特征对象 trait object
     * > https://github.com/rtpacks/rust-note/blob/main/docs/unit%2043-%E9%97%AD%E5%8C%85%20Closure%EF%BC%88%E4%B8%89%EF%BC%89%E5%BD%93%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E6%88%96%E8%BF%94%E5%9B%9E%E5%80%BC%E6%97%B6%E6%AD%A3%E7%A1%AE%E6%A0%87%E6%B3%A8%E5%87%BD%E6%95%B0%E7%AD%BE%E5%90%8D.md#%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC
     * 
     * 与其他语言不同，rust的特征（类似接口）是不能直接作为类型使用的，因为很多类型都实现某个特征，即实现该特征的类型（特征对象 trait object）并不固定，意味着特征对象(trait object) 也是一个动态尺寸类型。
     * 这很容里解释：Cat 和 Dog 都实现了 Speak，但是 Cat 和 Dog 的数据大小不相等，所以特征对象是一个动态尺寸类型。
     * ```rust
     * trait MyThing {};
     * fn foo_1(thing: &dyn MyThing) {}     // OK
     * fn foo_2(thing: Box<dyn MyThing>) {} // OK
     * fn foo_3(thing: MyThing) {}          // ERROR!
     * ```
     * 在闭包章节中提到过函数无法实现非固定大小的数据类型，需要使用特征对象的 `Box<dyn Fn(i32) -> i32>` 正确标注闭包作为返回值，就是因为特征对象 `dyn trait | trait object` 是一个动态尺寸类型，无法直接使用。
     * 
     * 总结：只能间接使用的 DST，Rust 中常见的 DST 类型有: `str`、`[T]`、`dyn trait | trait object`，它们都无法单独被使用，必须要通过引用或 Box 来间接使用。
     *
     */

    let array = [1, 2, 3];
    // let slice = array[..2]; 这是错误的，因为切片是一个动态大小的数据，因此只能存放在堆中，并不能直接使用
    //
    let slice = &array[..2];

    println!("{:p}, {:p}", &&array, slice);
}
