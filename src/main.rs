fn main() {
    /*
     *
     * ## async 异步编程：Pin 和 Unpin
     * 
     * 在之前的章节中介绍过，因为所有权和借用规则的存在，自引用结构体在 rust 中是比较多限制的。除了 `Rc + RefCell` 和 `unsafe` 方式，还可以使用 Pin 处理自引用结构体问题。
     *
     * 根据官方定义：**所有权转移的这个过程就是 move(移动)**。
     * 从**是否可以在内存中安全的被移动**的角度，rust 的类型分类两类，`Unpin` 和 `!Unpin`，具体的区分如下：
     *
     * - `Unpin` 表示类型**可以在内存中安全地移动**，即能安全的改变地址不会带来意外的错误。绝大多数标准库类型都实现了 Unpin。
     * - `!Unpin` 表示类型**在内存中移动可能会发生意外的副作用**，比如裸指针实现的自引用结构体，改变结构体地址后，存储的裸指针还是访问原地址，存在未定义行为的风险。
     *
     * > trait 特征前的 `!` 代表没有实现某个特征的意思，`!Unpin` 说明类型没有实现 Unpin 特征。
     *
     * 这些定义与名称会比较绕，`Unpin` 表示**不需要被固定就可以安全移动的类型**，`!Unpin` 表示没有实现 `Unpin` 特征的类型，也就是在内存移动中可能发生副作用的类型。
     * 为什么不用 Pin 和 Unpin？这是因为 rust 将 `Pin` 作为“动作”的智能指针（结构体），而不是特征，**`Pin` 表示固定一个值的地址**，它可以接收实现 `Unpin` 或 `!Unpin` 特征的类型。
     *
     * - 如果 Pin 的是 Unpin 类型，则还是可以被移动走的。因为实现 Unpin 就表示移动是安全的。
     * - 如果 Pin 的是 !Unpin 类型，则无法被移动走。因为 !Unpin 就表示移动是不安全的。
     * 
     * 
     * 
     *
     * TODO 自引用数据类型在 rust 中的问题引入 `Unpin` 和 `!Unpin`，rust 提供的 Pin 智能指针(结构体)提供了固定地址的功能。
     *
     *
     *
     * 什么时候使用 Pin？如果不希望某个被引用的内容发生改变，就可以使用 Pin。
     * Pin 的作用就是保证被其包裹的指针所指向的值不能被**改动**，Pin 防止其包裹指针所指向的内容不会变的实现就很简单，那就是不能获取其包裹指针的可变引用，这样就不能变
     *
     * Pin做的事情，就是制定一个编译器规则，让你在使用自引用类型的时候给予帮助/提示，防止你写出异常的代码。
     *
     *
     * 最后，Pin 生效的其实只有堆上的内容，因为保存在栈上的变量，本身也不需要靠指针来传递值，而是直接 Copy 内容，因此 Pin 不了栈上的变量。
     *
     */
}
