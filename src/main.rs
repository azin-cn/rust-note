fn main() {
    /*
     *
     * ## 并发(Concurrent)和并行(Parallel)
     * 在 Rust 中由于语言设计理念、安全、性能的多方面考虑，而是选择了多线程与 async/await 相结合。
     * 优点是可控性更强、性能更高，缺点是复杂度并不低，当然这也是系统级语言的应有选择：**使用复杂度换取可控性和性能**。
     *
     * 由于一个 CPU 核心在同一时刻只能执行一个任务，为了避免 IO 等阻塞操作占用 CPU，需要用并发和并行提高 CPU 利用率。并发和并行是两个概念，不完全相等。
     * - **并发（Concurrent）**是指一个 CPU 核心在一个极小的时间片段内，执行了多个任务的部分计算。即多个任务被处理，一次处理一个任务的一部分计算。
     * - **并行（Parallel）**是指多个 CPU 核心同时执行多个任务，一次可以执行多个任务。
     *
     * Erlang之父对于 Concurrent(并发) 和 Parallel(并行) 的解释:
     * - 单线程：一个咖啡机, 有多于两个队伍的人都需要使用这一个咖啡机接咖啡, 调度员只在一个队伍的人接到咖啡之后, 才允许下一个队伍使用这台咖啡机
     * - 单线程并发：仍然只有一个咖啡机, 队伍数量不变, 调度员这次取消了一个队伍的人全部接完咖啡后才能切换队伍的限制, 允许这次A队的人接, 下次B队的人接, 总体上队伍之间的进展比较协调
     * - 并行：有多个咖啡机，多个队伍可以同时接咖啡
     * - 1:1 并行：有几个队伍, 就有几个咖啡机, 队伍之间互不干扰
     * - M:N 并行：M个队伍, N个咖啡机 (M > N), 调度员可以根据情况, 选择让某几个队伍, **在某个咖啡机上, 形成单线程并发**
     *
     * 并发和并行都是对“多任务”处理的描述，其中并发是指多个任务被处理，一次处理一个任务的一部分计算，而并行是多个任务被同时处理。
     * 并发中 “多个任务同时存在” 中的 “同时” 指的是同一个时间段内，而并行中 “多个任务同时执行” 强调的是 一个时刻、时间点。
     * 所以同一个时间段内并不一定代表同时执行，但是一个时刻同时执行多个任务，那么在这个时刻周围的一段时间必然同时存在多个任务。
     * 
     * 
     * 因此，并发和并行总共可以分为三类：单核并发，多核并行，多核并发。
     * 
     *
     *
     */
}
