fn main() {
    /*
     *
     * ## async 异步编程：Pin 和 Unpin
     *
     * TODO 自引用数据类型在 rust 中的问题
     * unsafe 实现不能保证安全的原因是 value 的地址可能发生更改，`pointer_to_value` 记录 value 的原地址可能是一个未定义的数据，访问存在未定义行为的风险。
     *
     * > 比如完全克隆一份 `selfRef` 数据，然后释放原有的 `selfRef` 数据，此时新数据的 `selfRef.pointer_to_value` 存储的原 value 地址就是一个未定义的数据，访问此时的 `selfRef.pointer_to_value` 就是未定义的行为。
     *
     * 如果将 value 的地址固定，`pointer_to_value: *const` 就是一直有效的地址，不会存在未定义行为的风险。rust 提供的 Pin 智能指针(结构体)提供了固定地址的功能。
     *
     *
     * ### Pin Unpin !Unpin
     * 从**是否可以在内存中安全的被移动**的角度，rust 的类型分类两类，`Unpin` 和 `!Unpin`，具体的区分如下：
     *
     * - `Unpin` 表示类型**可以在内存中安全地移动**，即能安全的改变地址不会带来意外的错误。绝大多数标准库类型都实现了 Unpin。
     * - `!Unpin` 表示类型**在内存中移动可能会发生意外的副作用**，比如裸指针实现的自引用结构体，改变结构体地址后，存储的裸指针还是访问原地址，存在未定义行为的风险。
     *
     * > 特征前的 `!` 代表没有实现某个特征的意思，`!Unpin` 说明类型没有实现 Unpin 特征。
     *
     * 这些定义与名称会比较绕，`Unpin` 表示**不需要被固定就可以安全移动的类型**，`!Unpin` 表示没有实现 `Unpin` 特征的类型，也就是在内存移动中可能发生副作用的类型。
     * 为什么不用 Pin 和 Unpin？这是因为 rust 将 `Pin` 作为“动作”的智能指针（结构体），而不是特征，**`Pin` 表示固定一个值的地址**，它可以接收实现 `Unpin` 或 `!Unpin` 特征的类型。
     *
     * - 如果 Pin 的是 Unpin 类型，则还是可以被移动走的。因为实现 Unpin 就表示移动是安全的。
     * - 如果 Pin 的是 !Unpin 类型，则无法被移动走。因为 !Unpin 就表示移动是不安全的。
     *
     *
     *
     *
     *
     *
     *
     * Pin的作用就是保证被其包裹的指针所指向的值不能被**改动**
     *
     * Pin 防止其包裹指针所指向的内容不会变的实现就很简单，那就是不能获取其包裹指针的可变引用，这样就不能变
     *
     * 什么时候使用 Pin？如果不希望某个被引用的内容发生改变，就可以使用 Pin。Pin 是一个防止值被修改的作用。
     *
     * 最后，Pin 生效的其实只有堆上的内容，因为保存在栈上的变量，本身也不需要靠指针来传递值，而是直接 Copy 内容，因此 Pin 不了栈上的变量。
     *
     *
     *
     */
}
