fn main() {
    /*
     * ## 作用域
     *
     * 注意：{:p}打印的是给定位置/变量（具名、匿名）的地址，而不是给定位置存储的值的地址。例如 `let n = 1; println!("{:p}", &n);` 此时打印的是 `&n` 这个匿名变量的地址，而不是 `1` 的地址。
     *
     * tips: 有关全局内存可以看文章分析，https://rust-book.junmajinlong.com/ch5/00.html
     *
     * ### 作用域的生成方式
     *
     * 在Rust中，任何一个可用来包含代码的大括号都是一个单独的作用域，作用域可以嵌套。其中不包含类似 `Struct {}` 定义数据类型的大括号，这种不属于作用域的定义大括号。具体的方式包括但不限于以下几种。
     * - if、while等控制流程语句中的大括号
     * - match模式匹配的大括号
     * - 单独的大括号
     * - 函数定义的大括号
     * - mod定义模块的大括号
     *
     * ### 注意
     * - 实际上，变量跳出作用域失效时，会自动调用Drop Trait的drop函数来销毁该变量绑定在内存中的数据，这里特指销毁堆和栈上的数据，而字符串 **字面量** 是存放在全局内存中的，它会在程序启动到程序终止期间一直存在，不会被销毁。
     *
     * ## 所有权
     * Rust中每一个值都会有一个所有者（变量）。这句话容易产生误会，需要分成以下几点来理解。
     * - 对于存储在栈的基本数据类型，每一个值都有一个所有者。
     * - 对于存储在堆的复杂数据类型，位置（变量）存储的是一个胖指针，胖指针的指针指向堆中实际数据。此时变量的值是胖指针，即变量是胖指针的所有者，而不是实际数据的所有者。由于胖指针的指针指向实际数据且为了简化表述方式，所以一般称变量是复杂数据的所有者，这点需要着重理解。
     * - 对于存储在全局内存的数据类型，如字符串字面量，变量存储的也是胖指针结构，并且在离开作用域时，不会释放全局内存的值。如果多个变量存储同一个字符串字面量，这些变量存储的胖指针都一样。
     *
     * ### 注意
     * - 引用是原始数据类型，存储在栈中，保存的值是地址值（指针）。引用对应的是位置（内存空间、变量）的概念。容易混淆的引用与值所有权的转移过程。既然引用是一个原始数据类型，那么在赋值给其他变量的过程中，实现的自然是Copy。举个例子，let n = String::from("Hello World") 是一个存储在堆中的数据类型，n存储的是一个胖指针结构。如果 let m = n; 则n失去值（胖指针）的所有权。但是当 let n = &String::from("Hello World"); let m = n;时，引用是原始数据类型，实现Copy语义，所以n是可以正常使用的。
     * - 引用是原始数据类型，存储的是地址，实现Copy语义，赋值后仍保留值（指向地址）的所有权。
     * - 基本数据类型存储在栈，变量存储的是基本数据值，赋值后人仍保留值（实际数据）的所有权。
     * - 复杂数据类型存储在堆，变量存储的是胖指针结构，赋值后失去值（胖指针）的所有权。
     * 以上就是数据和引用容易混淆的点，引用是类似存储基本数据的变量。
     *
     * ## Move、Copy语义
     * 默认情况下，将一个值保存到某个位置时总是进行值的移动，使得只有目标位置才拥有这个值，而原始变量将变回未初始化的状态。实际上，Move和Copy都是进行值的拷贝，不同点在于Move在拷贝完成后，将原始变量设置为未初始化状态，而Copy则保留原始变量，因为Move语义之后原始变量失去所有权，而Copy保留值所有权。
     *
     * ### 注意
     * Rust中基本数据都实现了Copy语义，特殊的元组当每个元素都是原始数据类型时也是Copy的，共享指针类型或共享应用类型也是Copy的。
     *
     * 要注意Copy和Clone时的区别，如果不考虑自己实现Copy trait和Clone trait，而是使用它们的默认实现，那么：
     * - Copy时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据。
     * - Clone时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据。
     * - 不同的数据实现不同的语义，不要完全依靠数据是否简单来判断实现的语义，如胖指针结构简单但是实现的是Move语义！
     *
     * 也就是说，Copy是浅拷贝，Clone是深拷贝，Rust会对每个字段每个元素递归调用clone()，直到最底部。
     *
     * 函数的参数和返回值和变量的形式行为一致，本质上是一个赋值的过程。
     *
     * ## 拓展知识
     * ```ts
     * fn main() {
     *      let a = 1;
     *      let b = String::from("Hello");
     *      let c = b;
     * }
     * ```
     * 内存的释放顺序是从c开始的，c具有值的所有权，离开作用域后，释放c变量，并释放值。b变量没有值的所有权，只释放b。c变量存储的就是值，直接释放。
     *
     * ## 引用和所有权的借用
     * 变量的引用分为可变引用和不可变引用，站在所有权借用角度上看，可变引用代表可变借用，不可变引用代表不可变借用。
     *
     * > 之前提到过，位置不仅仅只是一个简单的内存位置，它还有各种属性和状态，**这些属性和状态都是编译期间由编译器维护的，不会保留到运行期间。这个可变与不可变就是其中的一种属性。
     *
     * - 不可变引用：借用只读权，不允许修改其引用的数据。
     * - 可变引用：借用读写权，允许修改其引用的数据，需要引用一个可变变量。
     *
     * 具体来说，一个值的可变分为变量可变和引用可变，可以通过可变变量来修改值！可变引用也是通过借用可变变量的所有权来修改的！即
     * ```rs
     * let mut s = String::from("Hello");
     * s.push_str("World"); // 正确，可以通过可变变量修改值
     * let sref = & s;
     * // sref.push_str("World"); 错误，引用通过可变变量修改，要求引用借用了变量的读写（即要求引用是一个可变引用）
     * println!("{:p}", sref); // 0xe94ddaf920
     * let mref = &mut s;
     * mref.push_str("World"); // 正确，可变引用借用可变变量值的所有权（读写），允许修改值
     * println!("{:p}", mref); // 0xe94ddaf920
     * ```
     * 总结：
     * - Rust 中通过可变变量来修改值，可变引用通过借用可变变量的所有权（读写权）来达到修改值的目的。
     * - 可变引用需要从可变变量中生成，而不可变引用无论从可变变量还是不可变变量生成，只借用了变量的读权，所以不可变变量/不可变引用不能修改值。
     *
     * ## 可变引用的排他性
     * 在之前提到了，可变与不可变引用之间使用的联系，将一个引用使用创建到使用结束的范围成为引用作用域。这里还需要增加一句 “变量重新赋值”
     * - 不可变引用作用域不允许出现可变引用、变量重新赋值
     * - 可变引用作用域不允许出现可变引用、不可变引用、变量重新赋值
     *
     * 可以参考：https://rust-book.junmajinlong.com/ch6/04_understand_mutable_ref.html
     * 这一个总结可以用一个形象的锁来描述，**在第一次使用变量的可变引用或变量被重新赋值开始，会创建一个抢占式独占锁，** 这个值的锁会被后续出现的变量、可变引用、不可变引用抢占，抢占后会将之前值的引用都禁用。程序员可以在任意代码位置通过原始变量或引用来抢锁。
     * 结合以下几点理解
     * - 变量地址是不变的
     * - 引用存储的变量地址也是不变的
     * https://rust-book.junmajinlong.com/ch6/04_understand_mutable_ref.html
     *
     * 总结
     * - 不可变引用可以共享/共存
     * - 在判断Rust的所有权和生命周期时，可以将循环结构for {} 视为多个 {} 块组合而成的
     * - 某个位置每建立一次引用就记录一次，如果是建立不可变引用，则简单判断即可。如果对该位置进行可变引用或重新赋值，从此刻开始这个位置将只能存在单一使用者，使用者可以是原始变量，可以是新的可变引用或不可变引用，使用者由程序员指定代码可以随时更换，但保证任意时刻只能有一个使用者。
     *
     * ## 再次理解Move
     * 在之前的简单代码中，Move的实现似乎只有复杂数据转移的过程才会出现，实际上Move发生在 “使用值的时候”，当然使用值是指这个值是复杂数据类型，即没有实现Copy Trait的时候。
     *
     * ```rs
     * let a = &vec![1,2,3];
     * let b = *a; // error
     * let b = (*a).clone(); // 宏如println!()不会获取该值的所有权
     * ```
     * 这是因为 vec 的所有权在某一个匿名变量上，a只是这个匿名变量的引用，不具有 vec 值的所有权，所以 *a 使用值时发生Move，而 a 没有所有权就会报错。
     *
     * ### 注意
     * 这也是常见的，使用值时丢失所有权的情况。记住：Move发生在使用值时。
     *
     * ```rs
     * let a = String::from("Hello world");
     * a; // 使用值，Move发生丢失所有权，类似 let _tmp = a;
     * let b = a; // error
     * ```
     *
     * 常见的错误写法是
     * ```rs
     * let a = String::from("Hello World");
     * let b = {
     *      a // 作为作用域的返回值，a失去所有权
     * }
     * println!("{}", a);
     * ```
     *
     * 从结果上看，语句块将 a 通过返回值的方式移出来赋值给b，所以认为 a 的所有权转移给了 b。实际上 a 的所有权首先转给了临时变量，然后返回时临时变量所有权又发生了移动，给了b
     *
     * ## 理解 “使用值的时候”
     * 这是一个重点，在编写Rust代码时，心智负担最终的便是考虑什么时候使用值！
     *
     * 有哪些地方会使用值呢？除了比较明显的会移动的情况，还有一些隐式的移动(或Copy)：
     * - 方法调用的真实接收者，如a.meth()，a会被移动(注意，a可能会被自动加减引用，此时a不是方法的真实接收者)
     * - 解引用时会Move(注意，解引用会得到那个值，但不一定会消耗这个值，有可能只是借助这个值去访问它的某个字段、或创建这个值的引用，这些操作可以看作是借值而不是使用值，如 let u = &String::from("H"); let uu = &(*u); )
     * - 字段访问时会Move那个字段 对象某个属性被Move
     * - 索引访问时，会Move那个元素 数组某个属性被Move
     * - 大小比较时，会Move(注意，a > b比较时会先自动取a和b的引用，然后再增减a和b的引用直到两边类型相同，因此实际上Move(Copy)的是它们的某个引用，而不会Move变量本身)
     */

    {
        // s 在这里无效, 它尚未声明
        let s = "hello"; // 从此处起，s是有效的
        println!("{}", s); // 使用 s
    } // 此作用域已结束，s不再有效 println!("{}", s) error

    // 验证全局内存
    {
        let hello = "hello"; // 字符串字面量数据存储全局内存
        let one = 1;
        println!("{:p}, {:p}", hello, &one);
    }

    let hello = "hello";
    let one = 1;
    let one_c = one;
    println!("{:p}, {:p}, {:p}", hello, &one, &one_c);

    let s = String::from("Hello world");
    let sp = &s;
    let spp = &sp;

    println!("{:p}, {:p}", sp, spp);

    // 全局内存，字符串字面量都是相同的
    let a = "Hello world";
    let b = "Hello world";
    println!("{:p}, {:p}", a, b); // 0x7ff75d38f4f8, 0x7ff75d38f4f8

    let a = &String::from("Hello world");
    let b = a;
    println!("{}, {}", a, b);

    // 使用clone方法
    let a = String::from("Hello world");
    let b = a.clone();
    println!("{:p}, {}", &a, b);

    // 所有权方法
    let mut s = String::from("Hello");

    s.push_str("World");
    let sref = &s;
    println!("{:p}", sref);

    let mref = &mut s;
    mref.push_str("World");

    println!("{:p}", mref);

    // 复杂的引用
    let mut x = Box::new(42);
    let mut p = &x;

    for i in 1..=3 {
        // println!("{:p}", p);

        x = Box::new(i);
        // 当第一次使用可变引用或变量被重新赋值时，就会创建一把独占锁，后续的可变引用、不可变引用、变量都会抢占。
        // 某个位置每建立一次引用就记录一次，如果是建立不可变引用，简单判断即可。如果对该位置进行可变引用或重新赋值，从此刻开始这个位置将只能存在单一使用者，使用者可以是原始变量，可以是新的可变引用或不可变引用，使用者由程序员指定代码可以随时更换，但保证任意时刻只能有一个使用者。

        p = &x;
    }

    // 再次理解Move
    let a = &1;
    let b = *a;
    println!("{}", b);

    let a = String::from("Hello World");
    a;
    // let b = a; error

    let a = String::from("value");
    println!("{:p}", &a);

    let b = {
        a // 这里创建了一个临时变量接收了a的所有权，返回时语句块又将临时变量的所有权转移给了b
    };
    println!("{:p}", &b);
}
