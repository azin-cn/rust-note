fn main() {
    /*
     * ## 泛型
     *
     * ### 介绍
     * 在编程语言中，变量名是对编程人员友好的名称，在编译期间，变量名会被转换为可被机器识别的内存地址。
     * 变量保存了什么数据，变量名就被替换为该数据的内存地址。
     * 也就是说，有了变量，编程人员可以使用更友好的变量名而不是使用内存地址来操作内存中的数据。
     *
     * 也可以将变量理解为是对内存中数据的抽象，无论是什么数据值，在编写代码的阶段，都可以用变量来表示这些数据。
     * 而在编译阶段，变量则会被替换为它所代表的内存数据。
     * 除了可以使用变量来代表数据，在支持泛型(Generic)的编程语言中，还可以使用泛型来代表各种各样可能的数据类型。
     *
     * 泛型之于数据类型，和变量之于内存数据，是类似的。
     * 在编写代码阶段，泛型可以表示各种各样的数据类型，(对于Rust来说)在编译阶段，泛型会被替换为它所代表的数据类型，也就是Rust指的零抽象成本。
     *
     * 例如，不使用泛型时，定义一个参数允许为u8、i8、u16、i16、u32、i32......等类型的double函数时：
     * ```rs
     * fn double_u8(i: u8) -> u8 { i + i }
     * fn double_i8(i: i8) -> i8 { i + i }
     * fn double_u16(i: u16) -> u16 { i + i }
     * fn double_i16(i: i16) -> i16 { i + i }
     * fn double_u32(i: u32) -> u32 { i + i }
     * fn double_i32(i: i32) -> i32 { i + i }
     * fn double_u64(i: u64) -> u64 { i + i }
     * fn double_i64(i: i64) -> i64 { i + i }
     *
     * fn main(){
     *   println!("{}",double_u8(3_u8));
     *   println!("{}",double_i16(3_i16));
     * }
     * ```
     *
     * 上面定义了一堆double函数，函数的逻辑部分是完全一致的，仅在于类型的不同。泛型可以用于解决这样因类型而代码冗余的问题。使用泛型时：
     * ```rs
     * use std::ops::Add;
     * fn double<T>(i: T) -> T
     *   where T: Add<Output=T> + Clone + Copy {
     *   i + i
     * }
     *
     * fn main(){
     *   println!("{}",double(3_i16));
     *   println!("{}",double(3_i32));
     * }
     * ```
     * 字母T就是**泛型参数**(和变量x的含义是相同的)，它用来代表**各种可能的数据类型**。多数时候泛型使用单个大写字母来表示，但也可以使用多个字母来表示。
     *
     * 对于double函数签名的前一部分：
     * ```rs
     * fn double<T>(i: T) -> T
     * ```
     * 函数名称后面的 `<T>` 表示在函数作用域内定义一个泛型T，这个泛型只能在函数签名和函数体内使用，和在一个作用域内定义一个变量，这个变量只能在该作用域内使用是一样的。
     * 而且，**泛型本就是代表各种数据类型的变量**。
     *
     * 参数部分i: T表示参数i的类型是泛型T。返回值部分-> T表示该函数的返回值类型是泛型T。
     * 因此，上面这部分函数签名表达的含义是：传入某种数据类型的参数，也返回这种数据类型的返回值，且这种数据类型可以是任意的类型。
     *
     * 记录：
     * - Trait Object（特征对象）是多态中的**动态分派**，它在编译期间无法确定数据的类型，所以在运行时只能使用 &dyn Trait 的形式。并且Trait Object虽然是由其他类型的实例转换而来的，但是当转为Trait Object后就会遗忘具体的数据类型（因为Trait Object可能来自多个不同的类型），所以Trait Object的vtable只记录了当前Trait的方法！也就是只能调用当前Trait的方法。
     * - 泛型在Rust中是被称为多态的实现方式中**静态分派**的一类，它能够在编译期间确定数据类型。例如编写了 `fn double<T>(i: T) -> T`，在编译期间rust会找到所有调用者并确定类型，如 `i32, i64` 等等。然后为每一种类型生成对应的函数，相当于简化了编写多个类型的`double`函数。这也是Rust称为零成本抽象的原因。
     */

    use std::ops::Add;

    fn double<T>(i: T) -> T
    where
        T: Add<Output = T> + Clone + Copy,
    {
        i + i
    }

    println!("{}", double(3_i16));
    println!("{}", double(3_i32));
}
