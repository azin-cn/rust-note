use std::fmt::Debug;

fn main() {
    /*
     * ## 生命周期
     *
     * 拜读 [Pluveto关于Rust生命周期标注的回答](https://www.zhihu.com/question/435470652) 和 [course.rs 教程](https://course.rs/basic/lifetime.html) 后，已经明白生命周期和生命周期标注的作用。
     * 用八个字来说：**必须确保依赖有效。**
     *
     * 生命周期，简而言之就是引用的有效作用域。这里定义一个**值的有效期：开始于自身作用域的开始，结束于自身依赖项的作用域结束。**
     *
     * ```rs
     * 0 {
     * 1     let r;
     * 2
     * 3     {
     * 4         let x = 5;
     * 5         r = &x;
     * 6     }
     * 7
     * 8     println!("r: {}", r);
     * 9 }
     * ```
     * 在上面的代码中，r 的（原本）作用域：1~9 行，r的依赖的作用域：4~5 行。因此，r 的真实有效期为 1~5 行。故第 8 行引用了无效的 r，因此编译报错。
     * 也就是说在正常无依赖的情况下，r的作用域是1~8行，但由于中间改变了r的依赖，所以r的作用域就变成：r作用域的开始到r的依赖的作用域结束。在第8行引用r，此时超出r的有效作用域，所以编译报错。
     *
     * 一般为了方便表达和使用，如函数调用的生命周期在不同的调用位置（参数）不一样，不会使用行这种概念来表达而是使用生命周期标注。
     * 生命周期标注以 `'` 开头，名称往往是一个单独的小写字母，大多数人都用 `'a` 来作为生命周期的名称。
     * 如果是引用类型的参数，那么生命周期会位于引用符号 & 之后，并用一个空格来将生命周期和引用参数分隔开。
     *
     * ```rs
     * &i32        // 一个引用
     * &'a i32     // 具有显式生命周期的引用
     * &'a mut i32 // 具有显式生命周期的可变引用
     * ```
     *
     * 上述r的生命周期换成生命周期标注解释如下：
     * ```rs
     * {
     *     let r;                // ---------+-- 'a
     *                           //          |
     *     {                     //          |
     *         let x = 5;        // -+-- 'b  |
     *         r = &x;           //  |       |
     *     }                     // -+       |
     *                           //          |
     *     println!("r: {}", r); //          |
     * }                         // ---------+
     * ```
     * 对于无依赖的r变量，整个生命周期是 'a，依赖x变量的整个生命周期是 'b，r依赖x后r的有效生命周期就变成r的作用域开始到x的作用域结束，`println("r: {}", r)`的位置超出了r的有效作用域，所以编译报错。
     *
     * 注意：**一个生命周期标注，它自身并不具有什么意义，因为生命周期的作用就是告诉编译器多个引用之间的关系。**
     *
     * 例如，有一个函数，它的第一个参数 first 是一个指向 i32 类型的引用，具有生命周期 'a，该函数还有另一个参数 second，它也是指向 i32 类型的引用，并且同样具有生命周期 'a。
     * 此处生命周期标注仅仅说明，让编译器明白这两个参数 first 和 second 至少活得和 'a 一样久，也就是在生命周期 'a 的范围内，first和second是不会发生问题的。但至于到底活多久或者哪个活得更久无从得知。
     * ```rs
     * fn useless<'a>(first: &'a i32, second: &'a i32) {
     *      ...
     * }
     * ```
     *
     * 在大多数时候，我们无需手动的声明生命周期，因为编译器可以自动进行推导。
     * 用类型来类比：大部分时候编译器可以自动推导类型 <->，也可以自动推导生命周期。
     * 但当条件复杂，如多种类型存在时，编译器往往要求我们手动标明类型 <->。
     * 所以当多个生命周期存在且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期。
     *
     * ```rs
     * fn longest(x: &str, y: &str) -> &str {
     *     if x.len() > y.len() {
     *         x
     *     } else {
     *         y
     *     }
     * }
     *
     * let string1 = String::from("abcd");
     * let string2 = "xyz";
     *
     * let result = longest(string1.as_str(), string2);
     * println!("The longest string is {}", result);
     * ```
     * 分析上面的依赖：longest 的返回值记作 a，a 依赖 x, y，而 x, y 的有效期未知（引用类型），导致 r 的有效期未知，故不安全。
     *
     * 解决的方法很简单，标注返回值的生命周期 'a 到 x, y 上，从而表明返回值 a 的依赖项 x, y 具有相同有效期（或者说，x, y 的有效期大于等于 a），通过检查。
     * 这里详细的解释是：返回值依赖于x，也依赖于y，编译器不会像人一样能够轻松推断在longest函数中x和y一直是有效的。
     * 因此用一个返回值的生命周期标注x和y，表明在这个过程中x和y是不会出现问题，是安全正常的，即x和y的有效作用域大于等于 'a。
     * 通过这种方式，我们给编译器提示了依赖安全，确保引用合法。
     * ```rs
     * fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
     *     if x.len() > y.len() {
     *         x
     *     } else {
     *         y
     *     }
     * }
     * ```
     *
     * ### 阅读
     * - https://www.zhihu.com/question/435470652
     * - https://course.rs/basic/lifetime.html
     *
     */

    let mut x = &0;
    {
        let y = 1;
        x = &y;
        println!("{x}");
    }
    // println!("{x}"); error

    // fn longestE(x: &str, y: &str) -> &str {
    //     if x.len() > y.len() {
    //         x
    //     } else {
    //         y
    //     }
    // }

    // 函数内的生命周期
    fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
        if x.len() > y.len() {
            x
        } else {
            y
        }
    }
    println!("{}", longest("测试数据1", "测试数据2"));
}
