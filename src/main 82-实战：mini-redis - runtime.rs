use async_std::prelude::*;
use futures::{future, StreamExt};
use std::time::Duration;

fn main() {
    /*
     *
     * ## 实战：mini-redis - runtime
     * 对于 Async Rust，最最重要的莫过于底层的异步运行时，它提供了执行器、任务调度、异步 API 等核心服务。
     * 这是因为 Rust 语言本身只提供了异步编程所需的基本特性和标准，例如 async/await 关键字，标准库中的 Future 特征，官方提供的 futures 实用库。
     * 这些特性单独使用没有任何用处，因此需要一个运行时来将这些特性实现的代码运行起来。
     *
     * 异步运行时是由 Rust 社区提供的，它们的核心是一个 reactor 和一个或多个 executor(执行器):
     * - reactor 用于提供外部事件的订阅机制，例如 I/O 、进程间通信、定时器等
     * - executor 用于调度和执行相应的任务( Future )
     * 目前最受欢迎的几个运行时有:
     * - tokio，目前最受欢迎的异步运行时，功能强大，还提供了异步所需的各种工具(例如 tracing )、网络协议框架(例如 HTTP，gRPC )等等
     * - async-std，最大的优点就是跟标准库兼容性较强
     * - smol, 一个小巧的异步运行时
     *
     * 因为**异步运行时的兼容性**问题，所以选择异步运行时非常重要。不仅仅是它们在功能、性能上存在区别，更重要的是当选择了一个，往往就无法切换到另外一个，除非异步代码很少。
     * 使用异步运行时，往往伴随着对它相关的生态系统的深入使用，因此耦合性会越来越强，直至最后你很难切换到另一个运行时，例如 tokio 和 async-std ，就存在这种问题。
     *
     * ### tokio
     *
     * 阅读：https://course.rs/advance-practice/overview.html#tokio-简介
     *
     * tokio 是 Rust 最优秀的异步运行时框架，它提供了写异步网络服务所需的几乎所有功能，不仅仅适用于大型服务器，还适用于小型嵌入式设备，它主要由以下组件构成：
     * - 多线程版本的异步运行时，可以运行使用 async/await 编写的代码
     * - 标准库中阻塞 API 的异步版本，例如 thread::sleep 会阻塞当前线程，tokio 中就提供了相应的异步实现版本
     * - 构建异步编程所需的生态，甚至还提供了 tracing 用于日志和分布式追踪， 提供 console 用于 Debug 异步编程
     *
     *
     * 注意：虽然 tokio 对于大多数需要并发的项目都是非常适合的，但是确实有一些场景如涉及到 CPU 密集型时，它并不适合使用:
     * - **并行运行 CPU 密集型的任务**。tokio 非常适合于 IO 密集型任务，这些 IO 任务的绝大多数时间都用于阻塞等待 IO 的结果，如果应用是 CPU 密集型(例如并行计算)，建议使用 rayon，当然，对于其中的 IO 任务部分，依然可以混用 tokio。
     * - **读取大量的文件**。读取文件的瓶颈主要在于操作系统，因为 OS 没有提供异步文件读取接口，大量的并发并不会提升文件读取的并行性能，反而可能会造成不可忽视的性能损耗，因此建议使用线程(或线程池)的方式
     * - 发送少量 HTTP 请求。tokio 的优势是并发处理大量任务，对于轻量级 HTTP 请求场景，tokio 无法带来什么额外的优势。因此，可以使用 reqwest 库，它更加简单易用。
     *
     * > 理解：
     * >
     * > async 异步运行时是基于非阻塞任务的假设设计的，在大部分时候都是基于**单线程异步并发**的认识去使用 async/await，这与 JavaScript 的单线程事件循环（event loop）是类似的。
     * > async 异步运行时假设任务会在遇到 I/O 操作或其他需要等待的操作时会让出控制权（例如通过 await，由 Waker 触发执行器 poll 获取 Future 状态后决定是否需要继续运行），如果任务执行了阻塞操作，那么在线程解除阻塞前任务不会让出线程的控制权，调度器无法将正在执行的任务迁移到其他线程。
     * >
     * > 异步任务调度器依赖于任务的非阻塞特性来高效地调度任务。除了单线程异步并发外，异步运行时（如 async-std 和 tokio）通常还会使用一个线程池来**并行**执行任务。
     * > 线程池中的每个线程都会执行一个事件循环（event loop）来处理任务队列中的任务，所以如果一个任务阻塞了当前线程，那么这个线程上的其他任务都会受到影响。
     *
     * **CPU 密集的任务**尤其需要用线程的方式去处理，例如使用 spawn_blocking 创建一个阻塞的线程去完成相应 CPU 密集任务。原因是：
     * tokio 是协作式的调度器，它的设计就是基于非阻塞任务的。如果某个 CPU 密集的异步任务是通过 tokio 创建的，那理论上来说，该异步任务需要跟其它的异步任务交错执行，最终都得到执行，皆大欢喜。
     * 但实际情况是，CPU 密集的任务很可能会一直霸占着 CPU，此时 tokio 的调度方式决定了该任务会一直被执行，这意味着其它的异步任务无法得到执行的机会，最终这些任务都会因为得不到资源而饿死。
     * 而使用 spawn_blocking 后，会创建一个单独的 OS 线程，该线程并不会被 tokio 所调度( 被 OS 所调度 )，因此它所执行的 CPU 密集任务也不会导致 tokio 调度的那些异步任务被饿死。
     *
     */
}
