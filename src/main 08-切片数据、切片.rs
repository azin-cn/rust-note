use std::vec;

fn main() {
    /*
     * ## Slice（切片）类型
     * 切片类型在现代语言中非常流行，它指定是从一个集合中选取连续/离散的局部数据。其中选取的操作过程叫做切片操作。
     *
     * Rust语言的切片操作只允许一段连续的数据，切片操作得到的数据称为切片数据简称切片（Slice），类型是[T]，切片数据（Slice）的引用简称切片引用，类型是&[T]。
     *
     * 切片数据简称切片，它三个易混淆的概念：切片数据的类型、切片数据的数据类型，切片数据的引用类型，即简称为切片类型、切片的数据类型，切片的引用类型。
     * - 切片类型是[T]，表示切片数据
     * - 切片的数据类型可以是任意类型T，表示切片数据存储单元的数据类型
     * - 切片的引用类型是&[T]，表示切片的引用，是最常见使用切片的方式
     *
     * Rust常见的数据类型中，有三种类型已支持Slice操作：String类型、Array类型和Vec类型(Slice类型自身也支持切片操作)。实际上，用户自定义的类型也可以支持Slice操作，只要自定义的类型满足一些条件即可
     *
     * ### 切片生成的方式
     * 有以下几种切片方式：假设s是可被切片的数据
     * - s[n1..n2]：获取s中index=n1到index=n2(不包括n2)之间的所有元素
     * - s[n1..]：获取s中index=n1到最后一个元素之间的所有元素
     * - s[..n2]：获取s中第一个元素到index=n2(不包括n2)之间的所有元素
     * - s[..]：获取s中所有元素
     * - 其他表示包含范围的方式，如s[n1..=n2]表示取index=n1到index=n2(包括n2)之间的所有元素
     *
     * ### 知识点
     * 切片的引用类型是一个胖指针，它包含两份元数据：
     * - 第一份元数据是 **指向源数据中切片起点** 元素的指针
     * - 第二份元数据是切片数据中包含的元素数量，即切片的长度
     * 切片数据（切片）无法直接使用，原因是切片的长度是可以动态变化的，编译器不能在编译期确定切片具体的长度，而Rust的编译器是不允许直接使用大小不确定的数据类型，所以编译会失败，也就是不能直接使用切片数据。
     *
     * ### 再次理解 Slice
     * Slice到底是什么，在内存中是怎么表现的？在我学习时，我非常困扰。后来我发现了这个图 [Rust内存分布，请看切片部分！](https://www.cnblogs.com/88223100/p/Rust-memory-distribution.html)，总结想象以下部分。
     *
     * 同一块内存空间只有一个变量具有所有权，但同一块内存空间可以认为是多个小内存空间组成的。如以一个Vec为例
     * ```rs
     * let v = vec![1, 2, 3];
     * let sli = &vec[0..]
     * ```
     * v是整个Vec空间的所有者，但Vec空间是由1，2，3共同构成的，1，2，3可以形成连续的不同组合，如1，2。
     * 这些连续的不同组合就是切片数据（切片），由于Vec所有权绑定在其他变量上，所以切片也就无法直接使用，而是需要通过切片引用来使用。
     *
     * 形成切片数据（切片）的这种数据类型的原因除了可以灵活的选择数据范围，不必要重新创建外，另外一个重要点就是保持保持数据的正确性，具体可看 https://rustwiki.org/zh-CN/book/ch04-03-slices.html 示例。
     *
     * ### Slice 和数组
     * 可以直接将数组的引用当成slice来使用。即&arr和&mut arr当作不可变slice和可变slice来使用。
     *
     * 另外，在调用方法的时候，由于 `.` 操作符会自动创建引用或解除引用，因此Array可以直接调用Slice的所有方法。
     *
     * ### 总结
     * Rust中通过切片操作得到连续型切片数据。切片数据简称为切片，它的类型是[T]；切片数据的数据类型简称切片的数据类型，用T表示；切片数据的引用简称切片引用，用&[T]表示，是最常见的使用切片的方式。
     *
     * 切片是某些连续小内存空间（变量）组合成的动态大小的大连续空间，是没有这些内存空间的所有权的，只能通过引用来访问。
     */

    let arr = [1, 2, 3, 4];
    // let slice = arr[1..2]; 错误，无法直接使用切片数据，也就是无法直接
    let slice = &arr[0..=2];
    let ptr = &arr;
    println!("{:p}", &slice);
    println!("{:p}", slice);
    println!("{:p}", ptr);

    let v = vec![1, 2, 3];
    let sli = &v[0..];
}
