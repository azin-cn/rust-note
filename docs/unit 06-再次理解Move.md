## 作用域

注意：{:p}打印的是给定位置/变量（具名、匿名）的地址，而不是给定位置存储的值的地址。例如 `let n = 1; println!("{:p}", &n);` 此时打印的是 `&n` 这个匿名变量的地址，而不是 `1` 的地址。

tips: 有关全局内存可以看文章分析，https://rust-book.junmajinlong.com/ch5/00.html

### 作用域的生成方式

在 Rust 中，任何一个可用来包含代码的大括号都是一个单独的作用域，作用域可以嵌套。其中不包含类似 `Struct {}` 定义数据类型的大括号，这种不属于作用域的定义大括号。具体的方式包括但不限于以下几种。

- if、while 等控制流程语句中的大括号
- match 模式匹配的大括号
- 单独的大括号
- 函数定义的大括号
- mod 定义模块的大括号

### 注意

- 实际上，变量跳出作用域失效时，会自动调用 Drop Trait 的 drop 函数来销毁该变量绑定在内存中的数据，这里特指销毁堆和栈上的数据，而字符串 **字面量** 是存放在全局内存中的，它会在程序启动到程序终止期间一直存在，不会被销毁。

## 所有权

Rust 中每一个值都会有一个所有者（变量）。这句话容易产生误会，需要分成以下几点来理解。

- 对于存储在栈的基本数据类型，每一个值都有一个所有者。
- 对于存储在堆的复杂数据类型，位置（变量）存储的是一个胖指针，胖指针的指针指向堆中实际数据。此时变量的值是胖指针，即变量是胖指针的所有者，而不是实际数据的所有者。由于胖指针的指针指向实际数据且为了简化表述方式，所以一般称变量是复杂数据的所有者，这点需要着重理解。
- 对于存储在全局内存的数据类型，如字符串字面量，变量存储的也是胖指针结构，并且在离开作用域时，不会释放全局内存的值。如果多个变量存储同一个字符串字面量，这些变量存储的胖指针都一样。

### 注意

- 引用是原始数据类型，存储在栈中，保存的值是地址值（指针）。引用对应的是位置（内存空间、变量）的概念。容易混淆的引用与值所有权的转移过程。既然引用是一个原始数据类型，那么在赋值给其他变量的过程中，实现的自然是 Copy。举个例子，let n = String::from("Hello World") 是一个存储在堆中的数据类型，n 存储的是一个胖指针结构。如果 let m = n; 则 n 失去值（胖指针）的所有权。但是当 let n = &String::from("Hello World"); let m = n;时，引用是原始数据类型，实现 Copy 语义，所以 n 是可以正常使用的。
- 引用是原始数据类型，存储的是地址，实现 Copy 语义，赋值后仍保留值（指向地址）的所有权。
- 基本数据类型存储在栈，变量存储的是基本数据值，赋值后人仍保留值（实际数据）的所有权。
- 复杂数据类型存储在堆，变量存储的是胖指针结构，赋值后失去值（胖指针）的所有权。
  以上就是数据和引用容易混淆的点，引用是类似存储基本数据的变量。

## Move、Copy 语义

默认情况下，将一个值保存到某个位置时总是进行值的移动，使得只有目标位置才拥有这个值，而原始变量将变回未初始化的状态。实际上，Move 和 Copy 都是进行值的拷贝，不同点在于 Move 在拷贝完成后，将原始变量设置为未初始化状态，而 Copy 则保留原始变量，因为 Move 语义之后原始变量失去所有权，而 Copy 保留值所有权。

### 注意

Rust 中基本数据都实现了 Copy 语义，特殊的元组当每个元素都是原始数据类型时也是 Copy 的，共享指针类型或共享应用类型也是 Copy 的。

要注意 Copy 和 Clone 时的区别，如果不考虑自己实现 Copy trait 和 Clone trait，而是使用它们的默认实现，那么：

- Copy 时，只拷贝变量本身的值，如果这个变量指向了其它数据，则不会拷贝其指向的数据。
- Clone 时，拷贝变量本身的值，如果这个变量指向了其它数据，则也会拷贝其指向的数据。
- 不同的数据实现不同的语义，不要完全依靠数据是否简单来判断实现的语义，如胖指针结构简单但是实现的是 Move 语义！

也就是说，Copy 是浅拷贝，Clone 是深拷贝，Rust 会对每个字段每个元素递归调用 clone()，直到最底部。

函数的参数和返回值和变量的形式行为一致，本质上是一个赋值的过程。

## 拓展知识

```ts
fn main() {
     let a = 1;
     let b = String::from("Hello");
     let c = b;
}
```

内存的释放顺序是从 c 开始的，c 具有值的所有权，离开作用域后，释放 c 变量，并释放值。b 变量没有值的所有权，只释放 b。c 变量存储的就是值，直接释放。

## 引用和所有权的借用

变量的引用分为可变引用和不可变引用，站在所有权借用角度上看，可变引用代表可变借用，不可变引用代表不可变借用。

> 之前提到过，位置不仅仅只是一个简单的内存位置，它还有各种属性和状态，\*\*这些属性和状态都是编译期间由编译器维护的，不会保留到运行期间。这个可变与不可变就是其中的一种属性。

- 不可变引用：借用只读权，不允许修改其引用的数据。
- 可变引用：借用读写权，允许修改其引用的数据，需要引用一个可变变量。

具体来说，一个值的可变分为变量可变和引用可变，可以通过可变变量来修改值！可变引用也是通过借用可变变量的所有权来修改的！即

```rs
let mut s = String::from("Hello");
s.push_str("World"); // 正确，可以通过可变变量修改值
let sref = & s;
// sref.push_str("World"); 错误，引用通过可变变量修改，要求引用借用了变量的读写（即要求引用是一个可变引用）
println!("{:p}", sref); // 0xe94ddaf920
let mref = &mut s;
mref.push_str("World"); // 正确，可变引用借用可变变量值的所有权（读写），允许修改值
println!("{:p}", mref); // 0xe94ddaf920
```

总结：

- Rust 中通过可变变量来修改值，可变引用通过借用可变变量的所有权（读写权）来达到修改值的目的。
- 可变引用需要从可变变量中生成，而不可变引用无论从可变变量还是不可变变量生成，只借用了变量的读权，所以不可变变量/不可变引用不能修改值。

## 可变引用的排他性

在之前提到了，可变与不可变引用之间使用的联系，将一个引用使用创建到使用结束的范围成为引用作用域。这里还需要增加一句 “变量重新赋值”

- 不可变引用作用域不允许出现可变引用、变量重新赋值
- 可变引用作用域不允许出现可变引用、不可变引用、变量重新赋值

可以参考：https://rust-book.junmajinlong.com/ch6/04_understand_mutable_ref.html
这一个总结可以用一个形象的锁来描述，**在第一次使用变量的可变引用或变量被重新赋值开始，会创建一个抢占式独占锁，** 这个值的锁会被后续出现的变量、可变引用、不可变引用抢占，抢占后会将之前值的引用都禁用。程序员可以在任意代码位置通过原始变量或引用来抢锁。
结合以下几点理解

- 变量地址是不变的
- 引用存储的变量地址也是不变的
  https://rust-book.junmajinlong.com/ch6/04_understand_mutable_ref.html

总结

- 不可变引用可以共享/共存
- 在判断 Rust 的所有权和生命周期时，可以将循环结构 for {} 视为多个 {} 块组合而成的
- 某个位置每建立一次引用就记录一次，如果是建立不可变引用，则简单判断即可。如果对该位置进行可变引用或重新赋值，从此刻开始这个位置将只能存在单一使用者，使用者可以是原始变量，可以是新的可变引用或不可变引用，使用者由程序员指定代码可以随时更换，但保证任意时刻只能有一个使用者。

## 再次理解 Move

在之前的简单代码中，Move 的实现似乎只有复杂数据转移的过程才会出现，实际上 Move 发生在 “使用值的时候”，当然使用值是指这个值是复杂数据类型，即没有实现 Copy Trait 的时候。

```rs
let a = &vec![1,2,3];
let b = *a; // error
let b = (*a).clone(); // 宏如println!()不会获取该值的所有权
```

这是因为 vec 的所有权在某一个匿名变量上，a 只是这个匿名变量的引用，不具有 vec 值的所有权，所以 \*a 使用值时发生 Move，而 a 没有所有权就会报错。

### 注意

这也是常见的，使用值时丢失所有权的情况。记住：Move 发生在使用值时。

```rs
let a = String::from("Hello world");
a; // 使用值，Move发生丢失所有权，类似 let _tmp = a;
let b = a; // error

let mut a = &mut String::from("Hello");
a.push_str(" World");
a = &mut String::from("Hello");
println!("{}", a); // error

```

常见的错误写法是

```rs
let a = String::from("Hello World");
let b = {
     a // 作为作用域的返回值，a失去所有权
}
println!("{}", a);
```

从结果上看，语句块将 a 通过返回值的方式移出来赋值给 b，所以认为 a 的所有权转移给了 b。实际上 a 的所有权首先转给了临时变量，然后返回时临时变量所有权又发生了移动，给了 b

## 理解 “使用值的时候”

这是一个重点，在编写 Rust 代码时，心智负担最终的便是考虑什么时候使用值！

有哪些地方会使用值呢？除了比较明显的会移动的情况，还有一些隐式的移动(或 Copy)：

- 方法调用的真实接收者，如 a.meth()，a 会被移动(注意，a 可能会被自动加减引用，此时 a 不是方法的真实接收者)
- 解引用时会 Move(注意，解引用会得到那个值，但不一定会消耗这个值，有可能只是借助这个值去访问它的某个字段、或创建这个值的引用，这些操作可以看作是借值而不是使用值，如 let u = &String::from("H"); let uu = &(\*u); )
- 字段访问时会 Move 那个字段 对象某个属性被 Move
- 索引访问时，会 Move 那个元素 数组某个属性被 Move
- 大小比较时，会 Move(注意，a > b 比较时会先自动取 a 和 b 的引用，然后再增减 a 和 b 的引用直到两边类型相同，因此实际上 Move(Copy)的是它们的某个引用，而不会 Move 变量本身)
