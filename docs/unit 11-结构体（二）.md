## 结构体（二）

通过结构体，我们可以将相关联的数据片段联系起来并命名它们，这样可以使得代码更加清晰。在 impl 块中，你可以定义与你的类型相关联的函数，而方法是一种相关联的函数，让你指定结构体的实例所具有的行为。

Struct 就像面向对象的类一样，Rust 允许为 Struct 定义实例方法和关联函数，实例方法可被所有实例对象访问调用，关联函数类似于其他语言的类函数或静态方法。

- 实例方法第一个参数是 self（的各种形式），实例方法是所有实例对象可访问、调用的方法，由实例调用。
- 关联函数是指第一个参数不是 self(的各种形式)但和 Struct 有关联关系的函数，由结构体直接调用，称为关联函数(associate functions)，如 String::from("")。

什么是 self 呢？self 表示调用方法时的 Struct 实例对象(如 person.speak()时，self 就是 person，是具体的实例)，相当于其他语言中的 this。
self 的类型是 Self（大写），在结构体内部使用 Self 代替结构体本身，即 Self 是结构体的别名，比如 Person 结构体实例方法的第一个参数 self，它的类型就是结构体自身 Self，也就是 Person，这样在编写代码时无需重复指定类型。

上面说到，实例方法的第一个参数是 self，self 的类型是结构体类型 Self，结合所有权可以得到下面三种形式

- `fn f(self: Self)`：当 obj.f()时，转移 obj 的所有权，调用 f 方法之后，obj 将无效
- `fn f(self: &Self)`：当 obj.f()时，借用而非转移 obj 的只读权，方法内部不可修改 obj 的属性，调用 f 方法之后，obj 依然可用
- `fn f(self: &mut Self)`：当 obj.f()时，借用 obj 的可写权，方法内部可修改 obj 的属性，调用 f 方法之后，obj 依然可用

可以使用以下写法再次简化表达形式

- `fn f(self)`：当 obj.f()时，转移 obj 的所有权，调用 f 方法之后，obj 将无效
- `fn f(&self)`：当 obj.f()时，借用而非转移 obj 的只读权，方法内部不可修改 obj 的属性，调用 f 方法之后，obj 依然可用
- `fn f(&mut self)`：当 obj.f()时，借用 obj 的可写权，方法内部可修改 obj 的属性，调用 f 方法之后，obj 依然可用

### 拓展

与字段同名的方法将被定义为只返回字段中的值，而不做其他事情。这样的方法被称为 getters，Rust 并不像其他一些语言那样为结构字段自动实现它们。Getters 很有用，因为你可以把字段变成私有的，但方法是公共的，这样就可以把对字段的只读访问作为该类型公共 API 的一部分。

实际上，实例方法也属于关联函数。当作关联函数调用时，需要手动传递一个 self。

```rs
Person::plus_age(&mut p);
```
