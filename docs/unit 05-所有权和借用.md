## 认识 Rust 的内存

胖指针：除了指针信息外，还保存有额外的元信息。

Rust 内存中，需要着重理解位置表达式和值这两个概念。

### 位置表达式

其中，变量名是易于读取的指针表达，是内存地址的别名。变量就是一个位置（位置表达式，内存位置）！有自己的地址，自己的空间，自己。可能位于栈，可能位于堆，还可能位于全局内存区。
变量名是内存地址的别名，供人阅读；变量（位置）是一块内存，有自己的地址，自己的空间，自己保存的值。
https://rust-book.junmajinlong.com/ch5/03_rust_place_value.html

### 值

值就是存储到位置中的数据(即保存在内存中的数据)。值的类型有多种，如数值类型的值、字符类型的值、指针类型的值(包括裸指针和胖指针)。

### 注意

- 每个位置（变量）就是它存储的值的所有者，因为每个值都只能存在一个位置，所以只能有一个所有者。
- 有时候，会将声明变量时的位置看作是变量(注意不是变量名)，或者将变量看作是位置。无论如何看待两者，我们内心需要明确的是，在能视为变量的情况下，变量或这种位置，是栈中的一块内存。
- 有时候，不能将位置视作变量。例如如果赋值给变量的是保存在堆中的数据(例如 Vec 类型)，那么变量中保存的是该数据的胖指针而不是。

###

```rs
let n = 1;
let v = vec![1, 2, 3, 4];
```

这两个变量产生的位置（内存）不一样的。

- 首先是 n 变量的声明，因为值 1 是原始数据类型，所以在 n 变量声明时，栈中开辟的一个位置（内存）可以直接存放值 1。也就是说 n 这个变，内存）自己的地址别名叫 n，代表的是这个位置（内存），存储的值是 1。
- 其次是 v 变量的声明，因为 Vec 不是原始数据类型，所以在声明 v 变量时，栈中开辟的一个位置（内存）不是存放实际数据的，存放的是一。这是因为在声明 v 变量时，显式开辟的栈内存（位置）就代表 v 变量，隐式开辟的堆中位置（内存）存放实际数据，栈位置（内存）存放的数址，所以堆位置不代表任何变量。

- 存储与堆的变量的值是那个胖指针，而不是堆中的那串实际数据。更严格地说，Vec 类型的值，指的是那个胖指针数据，而不是实际数据，变是那个胖指针而不是实际数据，变量 v 是胖指针这个值的所有者，而不是实际数据的所有者

## 所有权

所有权和借用是 Rust 控制内存的核心所在，参考一下文章。

- https://course.rs/basic/ownership/ownership.html
- https://github.com/sunface/rust-course/discussions/690#discussioncomment-3164352

### 注意

基本数据都是存储在栈上，实现 Copy 特征的，也就是在赋值给其他变量时，不会转移所有权！
复杂数据的值存储在堆上，堆的指针存储在栈上，实现 Move 特征，在赋值时会转移所有权，可以调用 clone()方法实现深度克隆。

Rust 是怎么保证内存安全呢？除了上述的操作之外，Rust 会在每一个块（函数）结束后，自动调用 drop 函数释放这个块（函数）内的**值**类型是复杂类型。

这是因为基本数据类型存储在栈中，当这个块（函数）执行完成后，栈会弹出这些变量即相应的值就会被销毁，而在堆中的复杂数据需要 drop 释放。
转移所有权的过程是将原有变量（存储在栈）的信息复制到新变量，然后将原变量设置为未初始化。

## 借用

Rust 变量因为所有权的存在，所以在赋值/传递时会很麻烦，借用（borrowing）就是处理这种情况的概念。

借用与所有权相对，是一种操作/概念/意图/解释，而引用是类型，为了实现借用这个操作的具体实现。即概念上这种操作是借用，具体代码中的数据类型称为引用。

borrowing 分为两种，不可变借用（不可变引用数据类型）和可变借用（可变引用数据类型），以下简称为不可变引用和可变引用。
可变引用需要可变变量/值，即 mut 修饰的变量/值，不可变引用没有限制。可变引用和可变变量是不同的概念。

```rs
& 引用
mut 可变
&mut 可变引用
let a 不可变变量
let mut a 可变变量

let a: String = String::from("hello world");
let b: &String = &String::from("hello world");
let c: &mut String = &mut String::from("Hello World");
let mut c: &mut String = &mut String::from("Hello World");
```

引用作用域定义为一个引用使用开始到使用结束的范围，变量作用域是变量创建开始到某一个`}`为止的范围。

总结规则

- 不可变引用作用域中不能出现可变引用
- 可变引用作用域中不能出现可变引用、不可能引用
